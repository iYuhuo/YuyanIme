# 语音识别性能优化说明

## 问题分析

原项目中语音识别存在以下性能问题：
1. 大模型加载缓慢：当用户选择体积较大的语音识别模型时，点击麦克风按钮会造成明显的卡顿
2. 每次点击都重新初始化：模型切换时完全释放并重新加载，造成延迟
3. 缺乏状态管理：没有区分模型初始化状态和就绪状态

## 优化方案（简化版）

### 1. 单模型管理策略
- **核心思路**：一次只使用一个模型，无需缓存多个模型
- **状态管理**：区分模型初始化状态和就绪状态
- **用户流程**：设置切换模型 → 检查模型状态 → 点击麦克风开始识别

### 2. 异步模型初始化 (SherpaOnnxRecognizer)
- **功能**：提供异步初始化方法，避免阻塞UI线程
- **优化**：减少垃圾回收等待时间，动态调整线程数
- **配置**：大模型使用单线程，小模型使用双线程

### 3. 智能模型切换 (VoiceRecognizer)
- **策略**：大模型异步初始化，小模型同步初始化
- **状态检查**：提供`isModelReady()`方法检查模型是否可用
- **错误处理**：模型未准备好时给出明确提示

### 4. 用户体验优化 (VoiceInputContainer)
- **状态提示**：根据不同情况显示相应的加载提示
- **超时保护**：3秒后提示用户模型加载超时
- **即时反馈**：点击麦克风时立即检查模型状态

## 性能提升效果

### 模型切换
- **优化前**：设置切换模型 → 点击麦克风 → 等待加载（完全阻塞）
- **优化后**：设置切换模型 → 异步加载 → 点击麦克风 → 检查状态 → 开始识别

### 大模型处理
- **优化前**：单线程加载，长时间阻塞UI
- **优化后**：单线程异步加载，不阻塞UI，显示进度提示

### 用户体验
- **优化前**：点击麦克风无响应，用户困惑
- **优化后**：点击麦克风立即反馈状态，提供明确指引

## 技术细节

### 线程优化
```kotlin
// 根据模型大小动态调整线程数
val numThreads = when {
    modelSize > 100 * 1024 * 1024 -> 1  // 大于100MB
    modelSize > 50 * 1024 * 1024 -> 2   // 大于50MB
    else -> 2                           // 普通模型
}
```

### 状态管理
```kotlin
// 大模型异步初始化
if (model.size > 50 * 1024 * 1024) {
    sherpaRecognizer.initializeAsync(model) { success ->
        if (success) {
            isModelReady = true
        }
    }
}

// 点击麦克风时检查状态
if (!voiceRecognizer.isModelReady()) {
    statusText.text = "⏳ 大模型加载中，请稍候..."
    return
}
```

## 使用流程

### 1. 模型切换（在设置中）
```kotlin
// 用户在设置中选择新模型
val success = voiceRecognizer.switchModel(newModelId)
if (success) {
    // 大模型：开始异步加载
    // 小模型：立即可用
}
```

### 2. 开始录音（点击麦克风）
```kotlin
// 检查模型是否准备好
if (!voiceRecognizer.isModelReady()) {
    showLoadingMessage()  // 显示加载提示
    return
}
// 模型准备好，开始录音
voiceRecognizer.startRecognition()
```

## 使用建议

1. **模型切换**：在大模型切换后，立即显示"模型加载中"提示，引导用户稍后使用
2. **首次使用**：小模型可以立即使用，大模型首次使用需要等待加载完成
3. **用户反馈**：始终提供清晰的状态提示，让用户了解当前情况

## 优势

- **简化架构**：移除复杂的缓存机制，专注单模型管理
- **即时反馈**：点击麦克风立即知道模型状态
- **渐进式体验**：小模型即时可用，大模型异步加载不阻塞
- **明确指引**：用户始终知道下一步该做什么
